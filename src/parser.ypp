// vim: set filetype=yacc :

%{
#include "ast/ast.hpp"
using namespace kompis;
using namespace ast;

extern "C"
{
  void yyerror(const char *);
  int yywrap();
}

int yylex();
%}

%token BOOLEAN CLASS ELSE FALSE IDENTIFIER IF INT INTEGER_LITERAL MAIN NEW PRINT PUBLIC RETURN STATIC STRING THIS TRUE VOID WHILE
%left ','
%right '='
%left AND
%left '<'
%left '+' '-'
%left '*'
%right '!'
%left '.'

%union
{
  Node *node;
  ClassDeclarationList *class_declarations;
  MethodDeclarationList *method_declarations;
  VariableDeclarationList *variable_declarations;
}

%type <node> program main_class class_declaration variable_declaration method_declaration parameter_rest type statements statement expression_list expression_rests expression_rest expression
%type <class_declarations> class_declarations
%type <variable_declarations> variable_declarations
%type <parameter_declarations> parameter_list parameter_rests
%type <method_declarations> method_declarations

%%

program
  : main_class class_declarations
    { $$ = new ProgramDeclaration((MainClassDeclaration *)$1, $2); }
  ;

main_class
  : CLASS IDENTIFIER '{' PUBLIC STATIC VOID MAIN '(' STRING '[' ']' IDENTIFIER ')' '{' statement '}' '}'
    { $$ = new MainClassDeclaration(NULL, (Statement *)$15); } // TODO
  ;

// Of the following two cases, the empty case will be executed first (and only
// once) ensuring that a new std::list will be allocated before any actual
// declarations are executed. (The same pattern is reused for all simple list
// types.)
class_declarations
  :
    { $$ = new std::list<ClassDeclaration *>(); }
  | class_declarations class_declaration
    { $$->push_back((ClassDeclaration *)$2); }
  ;

class_declaration
  : CLASS IDENTIFIER '{' variable_declarations method_declarations '}'
    { $$ = new ClassDeclaration(NULL, $4, $5); } // TODO
  ;

variable_declarations
  :
    { $$ = new std::list<VariableDeclaration *>(); }
  | variable_declarations variable_declaration
    { $$->push_back((VariableDeclaration *)$2); }
  ;

variable_declaration
  : type IDENTIFIER ';'
    { $$ = new VariableDeclaration((Type *)$1, NULL); } // TODO
  ;

method_declarations
  :
    { $$ = new std::list<MethodDeclaration *>(); }
  | method_declarations method_declaration
    { $$->push_back((MethodDeclaration *)$2); }
  ;

method_declaration
  : PUBLIC type IDENTIFIER '(' parameter_list ')' '{' variable_declarations statements RETURN expression ';' '}'
    { $$ = new MethodDeclaration((Type *)$2, NULL, NULL, $8, NULL, (Expression *)$11); } // TODO
  ;

parameter_list
  :
    // This clause ONLY gets executed for an empty parameter list.
    { $$ = new std::list<ParameterDeclaration *>(); }
  | type IDENTIFIER parameter_rests
    // This clause gets executed once, last, for a non-empty parameter list._rests
    { $$->push_front(NULL); }
  ;

parameter_rests
  :
    // This clause gets executed once, first, for a non-empty parameter list.
    { $$ = new std::list<ParameterDeclaration *>(); }
  | parameter_rests parameter_rest
    // This clause gets executed once for each element of a non-empty parameter list, after the parameter_rest clause.
    { $$->push_back((ParameterDeclaration *)$2); }
  ;

parameter_rest
  : ',' type IDENTIFIER
    // This clause gets executed once for each element of a non-empty parameter list, before the second parameter_rests clause.
    { $$ = new ParameterDeclaration((Type *)$2, NULL); }
  ;

type
  : BOOLEAN
    { $$ = new BooleanType(); }
  | INT
    { $$ = new IntegerType(); }
  | IDENTIFIER
    { $$ = new IdentifierType(NULL); } // TODO
  ;

statements
  :
    { $$ = NULL; }
  | statement statements // right recursive, to fix a shift/reduce conflict in method bodies
    { $$ = NULL; }
  ;

statement
  : '{' statements '}'
    { $$ = $2; }
  | IF '(' expression ')' statement ELSE statement
    { $$ = new IfThenElseStatement((Expression *)$3, (Statement *)$5, (Statement *)$7); }
  | WHILE '(' expression ')' statement
    { $$ = new WhileDoStatement((Expression *)$3, (Statement *)$5); }
  | PRINT '(' expression ')' ';'
    { $$ = new PrintStatement((Expression *)$3); }
  | IDENTIFIER '=' expression ';'
    { $$ = new AssignmentStatement(NULL, (Expression *)$3); } // TODO
  ;

expression_list
  :
    { $$ = NULL; }
  | expression expression_rests
    { $$ = NULL; }
  ;

expression_rests
  :
    { $$ = NULL; }
  | expression_rest expression_rests
    { $$ = NULL; }
  ;

expression_rest
  : ',' type IDENTIFIER
    { $$ = NULL; }
  ;

expression
  : INTEGER_LITERAL
    { $$ = new IntegerLiteral(0); } // TODO
  ;

/*
expression
  : expression '+' expression
    { $$ = new AdditionExpression($1, $2); }
  | expression '-' expression
    { $$ = new SubtractionExpression($1, $2); }
  | expression '*' expression
    { $$ = new MultiplicationExpression($1, $2); }
  | expression '<' expression
    { $$ = new LessThanExpression($1, $2); }
  | expression AND expression
    { $$ = new ConjunctionExpression($1, $2); }
  | expression '.' IDENTIFIER '(' expression_list ')'
    { $$ = new CallExpression($1, NULL, $3); }
  | INTEGER_LITERAL
    { $$ = new IntegerLiteral(yylval); }
  | TRUE
    { $$ = new BooleanLiteral(true); }
  | FALSE
    { $$ = new BooleanLiteral(false); }
  | IDENTIFIER
    { $$ = new IdentifierExpression(NULL); } // TODO
  | THIS
    { $$ = new ThisExpression(); }
  | NEW IDENTIFIER '(' ')'
    { $$ = new NewObjectExpression(NULL); } // TODO
  | '!' expression
    { $$ = new NegationExpression($2); }
  | '(' expression ')'
    { $$ = $2; }
  ;
*/

%%

extern int line_num;

void yyerror(const char *str)
{
  fprintf(stderr, "error on line %d: %s\n", line_num, str);
}

int yywrap()
{
  return 1; // ?
}

int main(int argc, char *argv[])
{
  yyparse();
  return 0;
}
