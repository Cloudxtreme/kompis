// vim: set filetype=yacc :

%{
#include <iostream>

#include "ast/ast.hpp"
#include "ast/pretty_printer.hpp"
#include "sema/type_checker.hpp"
using namespace kompis;
using namespace ast;
using namespace sema;

extern "C"
{
  void yyerror(const char *);
  int yywrap();
}

int yylex();

extern int line_num;

// These are used to subvert Bison's type system, or lack thereof.
ExpressionList *expressions;
ParameterDeclarationList *parameter_declarations;
ProgramDeclaration *program_declaration;
StatementList *statements;
%}

%token BOOLEAN CLASS ELSE FALSE IDENTIFIER IF INT INTEGER_LITERAL MAIN NEW PRINT PUBLIC RETURN STATIC STRING THIS TRUE VOID WHILE LENGTH
%left ','
%right '='
%left AND
%left '<'
%left '+' '-'
%left '*'
%right '!'
%left '.'
%left '['

// The list types in the union could be replaced by global variables.
%union
{
  int value;
  char *text;
  Node *node;
  ClassDeclarationList *class_declarations;
  ExpressionList *expressions;
  MethodDeclarationList *method_declarations;
  ParameterDeclarationList *parameter_declarations;
  StatementList *statements;
  VariableDeclarationList *variable_declarations;
}

%type <value> INTEGER_LITERAL
%type <text> IDENTIFIER
%type <node> program main_class class_declaration variable_declaration method_declaration parameter_rest type statement expression_rest expression
%type <class_declarations> class_declarations
%type <expressions> expression_list expression_rests
%type <method_declarations> method_declarations
%type <parameter_declarations> parameter_list parameter_rests
%type <statements> statements
%type <variable_declarations> variable_declarations

%%

program
  : main_class class_declarations
    { program_declaration = new ProgramDeclaration((MainClassDeclaration *)$1, $2, line_num); }
  ;

main_class
  : CLASS IDENTIFIER '{' PUBLIC STATIC VOID MAIN '(' STRING '[' ']' IDENTIFIER ')' '{' statement '}' '}'
    { $$ = new MainClassDeclaration((Statement *)$15, line_num); }
  ;

// Of the following two cases, the empty case will be executed first (and only
// once) ensuring that a new list will be allocated before any actual
// declarations are executed. (The same pattern is reused for all simple list
// types.)
class_declarations
  :
    { $$ = new ClassDeclarationList(); }
  | class_declarations class_declaration
    { $$->_list.push_back((ClassDeclaration *)$2); }
  ;

class_declaration
  : CLASS IDENTIFIER '{' variable_declarations method_declarations '}'
    { $$ = new ClassDeclaration(new Identifier($2, line_num), $4, $5, line_num); }
  ;

// See class_declarations for explanation.
variable_declarations
  :
    { $$ = new VariableDeclarationList(); }
  | variable_declarations variable_declaration
    { $$->_list.push_back((VariableDeclaration *)$2); }
  ;

variable_declaration
  : type IDENTIFIER ';'
    { $$ = new VariableDeclaration((Type *)$1, new Identifier($2, line_num), line_num); }
  ;

// See class_declarations for explanation.
method_declarations
  :
    { $$ = new MethodDeclarationList(); }
  | method_declarations method_declaration
    { $$->_list.push_back((MethodDeclaration *)$2); }
  ;

method_declaration
  : PUBLIC type IDENTIFIER '(' parameter_list ')' '{' variable_declarations statements RETURN expression ';' '}'
    { $$ = new MethodDeclaration((Type *)$2, new Identifier($3, line_num), $5, $8, $9, (Expression *)$11, line_num); }
  ;

// This is a slightly more complicated type of list.
parameter_list
  :
    // This clause ONLY gets executed for an empty parameter list.
    { $$ = parameter_declarations = new ParameterDeclarationList(); }
  | type IDENTIFIER parameter_rests
    // This clause gets executed once, last, for a non-empty parameter list.
    {
      parameter_declarations->_list.push_front(new ParameterDeclaration((Type *)$1, new Identifier($2, line_num), line_num));
      $$ = parameter_declarations;
    }
  ;

parameter_rests
  :
    // This clause gets executed once, first, for a non-empty parameter list.
    { parameter_declarations = new ParameterDeclarationList(); }
  | parameter_rests parameter_rest
    // This clause gets executed once for each element of a non-empty parameter list, after the parameter_rest clause.
    { parameter_declarations->_list.push_back((ParameterDeclaration *)$2); }
  ;

parameter_rest
  : ',' type IDENTIFIER
    // This clause gets executed once for each element of a non-empty parameter list, before the second parameter_rests clause.
    { $$ = new ParameterDeclaration((Type *)$2, new Identifier($3, line_num), line_num); }
  ;

type
  : INT '[' ']'
    { $$ = new IntegerArrayType(line_num); }
  | BOOLEAN
    { $$ = new BooleanType(line_num); }
  | INT
    { $$ = new IntegerType(line_num); }
  | IDENTIFIER
    { $$ = new IdentifierType($1, line_num); }
  ;

// See class_declarations for explanation.
statements
  :
    { $$ = statements = new StatementList(line_num); }
  | statement statements // right recursive, to fix a shift/reduce conflict in method bodies
    {
      statements->_list.push_front((Statement *)$1);
      $$ = statements;
    }
  ;

statement
  : '{' statements '}'
    { $$ = $2 }
  | IF '(' expression ')' statement ELSE statement
    { $$ = new IfThenElseStatement((Expression *)$3, (Statement *)$5, (Statement *)$7, line_num); }
  | WHILE '(' expression ')' statement
    { $$ = new WhileDoStatement((Expression *)$3, (Statement *)$5, line_num); }
  | PRINT '(' expression ')' ';'
    { $$ = new PrintStatement((Expression *)$3, line_num); }
  | IDENTIFIER '=' expression ';'
    { $$ = new AssignmentStatement(new Identifier($1, line_num), (Expression *)$3, line_num); }
  | IDENTIFIER '[' expression ']' '=' expression ';'
    { $$ = new ArrayAssignmentStatement(new Identifier($1, line_num), (Expression *)$3, (Expression *)$6, line_num); }
  ;

// See parameter_list for explanation.
expression_list
  :
    { $$ = expressions = new ExpressionList(); }
  | expression expression_rests
    {
      expressions->_list.push_front((Expression *)$1);
      $$ = expressions;
    }
  ;

expression_rests
  :
    { expressions = new ExpressionList(); }
  | expression_rests expression_rest
    { expressions->_list.push_back((Expression *)$2); }
  ;

expression_rest
  : ',' expression
    { $$ = $2; }
  ;

expression
  : expression '+' expression
    { $$ = new AdditionExpression((Expression *)$1, (Expression *)$3, line_num); }
  | expression '-' expression
    { $$ = new SubtractionExpression((Expression *)$1, (Expression *)$3, line_num); }
  | expression '*' expression
    { $$ = new MultiplicationExpression((Expression *)$1, (Expression *)$3, line_num); }
  | expression '<' expression
    { $$ = new LessThanExpression((Expression *)$1, (Expression *)$3, line_num); }
  | expression AND expression
    { $$ = new ConjunctionExpression((Expression *)$1, (Expression *)$3, line_num); }
  | expression '[' expression ']'
    { $$ = new ArraySubscriptExpression((Expression *)$1, (Expression *)$3, line_num); }
  | expression '.' LENGTH
    { $$ = new ArrayLengthExpression((Expression *)$1, line_num); }
  | expression '.' IDENTIFIER '(' expression_list ')'
    { $$ = new CallExpression((Expression *)$1, new Identifier($3, line_num), $5, line_num); }
  | INTEGER_LITERAL
    { $$ = new IntegerLiteral($1, line_num); }
  | TRUE
    { $$ = new BooleanLiteral(true, line_num); }
  | FALSE
    { $$ = new BooleanLiteral(false, line_num); }
  | IDENTIFIER
    { $$ = new IdentifierExpression($1, line_num); }
  | THIS
    { $$ = new ThisExpression(line_num); }
  | NEW INT '[' expression ']'
    { $$ = new NewIntegerArrayExpression((Expression *)$4, line_num); }
  | NEW IDENTIFIER '(' ')'
    { $$ = new NewObjectExpression(new Identifier($2, line_num), line_num); }
  | '!' expression
    { $$ = new NegationExpression((Expression *)$2, line_num); }
  | '(' expression ')'
    { $$ = $2; }
  ;

%%

extern int line_num;
//extern int yydebug;

void yyerror(const char *str)
{
  fprintf(stderr, "error on line %d: %s\n", line_num, str);
}

int yywrap()
{
  return 1; // ?
}

int main(int argc, char *argv[])
{
  //yydebug = 1;
  yyparse();

  if (program_declaration == NULL) {
    exit(1);
  }

  PrettyPrinter pp(std::cout);
  pp.visit(program_declaration);
  TypeChecker tc;
  tc.visit(program_declaration);
  return 0;
}
